///////////
// THIS CODE FILE WAS FOR >90% GENERATED BY GOOGLE AI GEMINI 2.5 PREVIEW 05-06
///////////

class Relation {
  constructor(e1, e2, type) {
    this.e1 = e1;
    this.e2 = e2;
    this.type = type;
    this.time = 0;
    this.strength = 50;
    this.positivity = 50;
    this.relationColor = color(getColor());

    // --- Tweakable Parameters ---

    // Undefined (Neutral) Relation
    this.undefined_strokeAlpha = 150;
    this.undefined_baseThicknessMin = 0.5;
    this.undefined_baseThicknessMax = 4;
    this.undefined_endFactor = 1.5;
    this.undefined_radiusInfluence = 0.05;
    this.undefined_animationSpeed = 0.005; // For particles

    // Balancing Relation
    this.balancing_lineBaseThickness = 0.5;
    this.balancing_lineStrengthThickness = 3;
    this.balancing_blobBaseSize = 6;
    this.balancing_blobStrengthSize = 10;
    this.balancing_blobMergeFactor = 1.6;
    this.balancing_animationSpeed = 0.015;

    // Flow Relation
    this.flow_lineBaseThickness = 1;
    this.flow_lineStrengthThickness = 4;
    this.flow_numArrowPairs = 3;
    this.flow_arrowBaseSize = 4;
    this.flow_arrowStrengthSize = 6;
    this.flow_animationSpeed = 0.008;
    this.flow_waveAmplitude = 10;
    this.flow_waveFrequency = 0.1;
    this.flow_waveTimeSpeed = 0.05;
    this.flow_segments = 20;

    // Resonance Relation
    this.resonance_rectBaseLength = 8;
    this.resonance_rectStrengthLength = 12;
    this.resonance_rectBaseWidth = 3;
    this.resonance_rectStrengthWidth = 8;
    this.resonance_lengthRatios = [1.0, 0.75, 0.5];
    this.resonance_animationSpeed = 0.006;
    this.resonance_spacingFactor = 1.5;

    // Delaying Relation
    this.delaying_lineBaseThickness = 0.5;
    this.delaying_lineStrengthThickness = 3;
    this.delaying_arrowBaseSize = 5;
    this.delaying_arrowStrengthSize = 8;
    this.delaying_animationSpeed = 0.003;
    this.delaying_leaderStartProgress = 0.15;
    this.delaying_followerRelativeSpeed = 1.1;
    this.delaying_leaderDecelerationFactor = 3;

    // Amplifying Relation
    this.amplifying_baseStrokeWeight = 0.5;
    this.amplifying_strengthStrokeWeight = 2.0; // Adjusted
    this.amplifying_baseAmplitude = 3; // Adjusted
    this.amplifying_strengthAmplitude = 15; // Adjusted
    this.amplifying_noiseScaleSpatial = 0.05;
    this.amplifying_noiseScaleTime = 0.05; // Adjusted
    this.amplifying_lineSegmentsIncrement = 2;
    this.amplifying_animationSpeed = 0.01; // General speed for particles if needed, soundLine uses time directly

    // Glow Effect (Parameters kept if you want to reuse drawGlow for other purposes)
    this.glow_blurSteps = 8;
    this.glow_maxOpacity = 70; // Was used for positivity glow
    this.glow_sizeFactor = 10.0;

    // Positivity Particles
    this.positivity_showParticles = true;
    this.positivity_particleBaseCountFactor = 0.15; // Particles per unit path length
    this.positivity_particleStrengthFactor = 1.2;
    this.positivity_particlePositivityFactor = 1.0;
    this.positivity_particleSizeMin = 4.0;
    this.positivity_particleSizeMax = 6.0;
    this.positivity_particleSpeedFactor = 0; // Multiplied by relation's animSpeedParam
    this.positivity_particleJitterMax = (this.e1.r + this.e2.r) / 2;
    this.positivity_darkParticleBaseColor = color(70, 70, 70);
    this.positivity_particleAlpha = 180;
    this.positivity_minParticles = 1;
    this.positivity_maxParticles = 30;

    // --- Label Configuration (NEW) ---
    this.label_show = true; // Set to false to hide label by default for this instance
    this.label_textColor = color(0); // Default text color (black)
    this.label_textSize = 11;
    this.label_textOffsetY = -15; // Pixels above the line's center
    this.label_showBackground = true;
    this.label_backgroundColor = color(255, 255, 255, 210); // Semi-transparent white
    this.label_backgroundPadding = 4;
    this.label_backgroundCornerRadius = 3;
    this.label_maxAngleDeg = 45; // Max tilt from horizontal in degrees
  }

  // Helper to get default label options from instance properties
  _getDefaultLabelOptions() {
    return {
      textColor: this.label_textColor,
      textSize: this.label_textSize,
      textOffsetY: this.label_textOffsetY,
      showBackground: this.label_showBackground,
      backgroundColor: this.label_backgroundColor,
      backgroundPadding: this.label_backgroundPadding,
      backgroundCornerRadius: this.label_backgroundCornerRadius,
      maxAngleDeg: this.label_maxAngleDeg,
    };
  }

  /**
   * Displays the relation's label.
   * @param {object} [overrideOptions={}] Optional configuration to override instance defaults.
   */
  displayLabel(overrideOptions = {}) {
    const config = { ...this._getDefaultLabelOptions(), ...overrideOptions };

    const e1Pos = createVector(this.e1.x, this.e1.y);
    const e2Pos = createVector(this.e2.x, this.e2.y);

    if (p5.Vector.dist(e1Pos, e2Pos) < config.textSize * 2) {
      // Don't draw if too short
      return;
    }

    const midX = (e1Pos.x + e2Pos.x) / 2;
    const midY = (e1Pos.y + e2Pos.y) / 2;

    const delta = p5.Vector.sub(e2Pos, e1Pos);
    let lineAngle = delta.heading(); // Radians

    let textAngle = lineAngle;
    const maxAngleRad = radians(config.maxAngleDeg);

    if (textAngle > HALF_PI || textAngle < -HALF_PI) {
      textAngle += PI;
    }

    if (abs(textAngle) > maxAngleRad) {
      textAngle = 0; // Keep it horizontal if too steep
    }

    push();
    translate(midX, midY);
    rotate(textAngle);

    let labelText = this.type || "Unknown Type";
    if (labelText === "null") {
      labelText = "";
    }

    fill(config.textColor);
    textSize(config.textSize);
    textAlign(CENTER, CENTER);

    if (config.showBackground) {
      const tw = textWidth(labelText);
      const th = config.textSize;
      push();
      rectMode(CENTER);
      fill(config.backgroundColor);
      noStroke();
      rect(
        0,
        config.textOffsetY,
        tw + config.backgroundPadding * 2,
        th + config.backgroundPadding * 2,
        config.backgroundCornerRadius
      );
      pop();
    }

    text(labelText, 0, config.textOffsetY);
    pop();
  }

  display() {
    push();
    let e1Pos = createVector(this.e1.x, this.e1.y);
    let e2Pos = createVector(this.e2.x, this.e2.y);
    let delta = p5.Vector.sub(e2Pos, e1Pos);
    let angle = delta.heading();
    let d = delta.mag();

    if (d < 1) {
      pop();
      this.time += 1;
      return;
    }

    // Positivity-based glow has been removed.
    // The old centralized glow call block is removed. Specific relations handle their own visuals.

    // Call specific relation drawing function
    if (this.type === "undefined") {
      this.undefinedRelation(e1Pos, e2Pos, d, angle);
    } else if (this.type === "amplifying") {
      this.amplifying(e1Pos, e2Pos, d, angle);
    } else if (this.type === "balancing") {
      this.balancing(e1Pos, e2Pos, d, angle);
    } else if (this.type === "flow") {
      this.flow(e1Pos, e2Pos, d, angle);
    } else if (this.type === "resonance") {
      this.resonance(e1Pos, e2Pos, d, angle);
    } else if (this.type === "delaying") {
      this.delaying(e1Pos, e2Pos, d, angle);
    }
    pop();

    // --- Draw Label (after the relation itself, in global coordinates) ---
    // The displayLabel method handles its own push/pop and transformations.
    if (this.label_show) {
      this.displayLabel(); // Uses instance defaults (this.label_...)
      // Or you could pass overrides: this.displayLabel({ textColor: color('blue') });
    }

    this.time += 1; // Increment time for animations
  }

  // Glow effect method - currently unused as positivity glow is removed.
  // Kept in case you want to use it for non-positivity related glows later.
  drawGlow(p1, p2, d, ang, baseStrokeWeight) {
    // This version of glow was tied to positivity.
    // If you reuse, make it positivity-neutral or for other effects.
    // if (this.positivity === 50 || baseStrokeWeight <= 0) return;
    // ... (original glow logic) ...
  }

  _drawPositivityParticles(
    pathLength,
    getPointAndTangentAt,
    animSpeedParam = 0.01
  ) {
    if (
      !this.positivity_showParticles ||
      this.positivity === 50 ||
      pathLength < 5
    )
      return; // Min length for particles

    let particleCount =
      (pathLength *
        this.positivity_particleBaseCountFactor *
        abs(this.positivity - 50)) /
      100;
    particleCount *= map(
      this.strength,
      0,
      100,
      0.5,
      this.positivity_particleStrengthFactor
    ); // Apply strength factor
    particleCount *=
      (abs(this.positivity - 50) / 50) *
      this.positivity_particlePositivityFactor;
    particleCount = constrain(
      floor(particleCount),
      this.positivity_minParticles,
      this.positivity_maxParticles
    );

    if (particleCount === 0) return;

    let particleColorValue;
    if (this.positivity < 50) {
      particleColorValue = color(
        red(this.positivity_darkParticleBaseColor),
        green(this.positivity_darkParticleBaseColor),
        blue(this.positivity_darkParticleBaseColor),
        this.positivity_particleAlpha
      );
    } else {
      particleColorValue = color(
        red(this.relationColor),
        green(this.relationColor),
        blue(this.relationColor),
        this.positivity_particleAlpha
      );
    }
    fill(particleColorValue);
    noStroke();

    let effectiveAnimSpeed =
      typeof animSpeedParam === "number" ? animSpeedParam : 0.01;
    let baseSpeed =
      this.positivity_particleSpeedFactor * effectiveAnimSpeed * 100; // Scaled up a bit

    for (let i = 0; i < particleCount; i++) {
      let timeOffsetFactor = (i * 0.61803398875) % 1; // Golden ratio for pseudo-random but stable offset
      let progress =
        (this.time * baseSpeed + timeOffsetFactor * pathLength) % pathLength;
      let t = progress / pathLength;

      let pointData = getPointAndTangentAt(t);
      if (!pointData || !pointData.position || !pointData.tangent) continue;

      let { position, tangent } = pointData;
      let particleSize = random(
        this.positivity_particleSizeMin,
        this.positivity_particleSizeMax
      );

      let perpendicular = createVector(-tangent.y, tangent.x); // Already normalized by provider or normalized here
      if (tangent.magSq() > 0.0001 && perpendicular.magSq() === 0)
        perpendicular.set(tangent.x, tangent.y).rotate(HALF_PI); // handle purely vertical/horizontal
      if (perpendicular.magSq() === 0)
        perpendicular.set(0, 1); // ultimate fallback for jitter
      else perpendicular.normalize();

      let jitterOffset = random(
        -this.positivity_particleJitterMax,
        this.positivity_particleJitterMax
      );
      let finalPos = p5.Vector.add(position, perpendicular.mult(jitterOffset));

      ellipse(finalPos.x, finalPos.y, particleSize, particleSize);
    }
  }

  drawArrow(x, y, rot, size, col) {
    push();
    translate(x, y);
    rotate(rot);
    fill(col);
    noStroke();
    triangle(0, 0, -size, -size / 2, -size, size / 2);
    pop();
  }

  undefinedRelation(p1, p2, d, ang) {
    let midThickness = map(
      this.strength,
      0,
      100,
      this.undefined_baseThicknessMin,
      this.undefined_baseThicknessMax
    );
    let end1RadiusInfluence =
      this.e1.r * this.undefined_radiusInfluence * (this.strength / 100);
    let end2RadiusInfluence =
      this.e2.r * this.undefined_radiusInfluence * (this.strength / 100);
    let end1Thickness =
      midThickness * this.undefined_endFactor + end1RadiusInfluence;
    let end2Thickness =
      midThickness * this.undefined_endFactor + end2RadiusInfluence;

    let colWithAlpha = this.relationColor; // Assuming this returns a p5.Color object
    let tempAlpha = this.undefined_strokeAlpha; // Store original alpha setting

    // p5.Color objects are mutable. If relationColor is shared, this changes it globally.
    // It's better to create a new color or manage alpha carefully.
    // For now, assuming getColor() provides a fresh color object or this behavior is intended.
    let r = red(this.relationColor);
    let g = green(this.relationColor);
    let b = blue(this.relationColor);
    fill(r, g, b, tempAlpha);
    noStroke();

    push();
    translate(p1.x, p1.y);
    rotate(ang);
    beginShape();
    vertex(0, -end1Thickness / 2);
    quadraticVertex(
      d * 0.25,
      -lerp(end1Thickness, midThickness, 0.5) / 2,
      d * 0.5,
      -midThickness / 2
    );
    quadraticVertex(
      d * 0.75,
      -lerp(midThickness, end2Thickness, 0.5) / 2,
      d,
      -end2Thickness / 2
    );
    vertex(d, end2Thickness / 2);
    quadraticVertex(
      d * 0.75,
      lerp(midThickness, end2Thickness, 0.5) / 2,
      d * 0.5,
      midThickness / 2
    );
    quadraticVertex(
      d * 0.25,
      lerp(end1Thickness, midThickness, 0.5) / 2,
      0,
      end1Thickness / 2
    );
    endShape(CLOSE);

    const getPointAndTangent_Undefined = (t_norm) => {
      return {
        position: createVector(t_norm * d, 0),
        tangent: createVector(1, 0).normalize(),
      };
    };
    this._drawPositivityParticles(
      d,
      getPointAndTangent_Undefined,
      this.undefined_animationSpeed
    );

    pop();
    // colWithAlpha.setAlpha(255); // This line might not be needed if alpha is handled locally.
  }

  balancing(p1, p2, d, ang) {
    let lineThickness = map(
      this.strength,
      0,
      100,
      this.balancing_lineBaseThickness,
      this.balancing_lineBaseThickness + this.balancing_lineStrengthThickness
    );
    let blobSize = map(
      this.strength,
      0,
      100,
      this.balancing_blobBaseSize,
      this.balancing_blobBaseSize + this.balancing_blobStrengthSize
    );
    let progress = (this.time * this.balancing_animationSpeed) % 1;
    let mainCol = this.relationColor;

    push();
    translate(p1.x, p1.y);
    rotate(ang);
    stroke(mainCol);
    strokeWeight(lineThickness);
    line(0, 0, d, 0);
    fill(mainCol);
    noStroke();

    let movePhaseEnd = 0.4;
    let mergePhaseEnd = 0.6;
    let disappearPhaseEnd = 1.0;

    if (progress < movePhaseEnd) {
      let phaseProgress = map(progress, 0, movePhaseEnd, 0, 1);
      let pos1 = lerp(0, d / 2 - blobSize * 0.6, phaseProgress);
      let pos2 = lerp(d, d / 2 + blobSize * 0.6, phaseProgress);
      ellipse(pos1, 0, blobSize, blobSize);
      ellipse(pos2, 0, blobSize, blobSize);
    } else if (progress < mergePhaseEnd) {
      let phaseProgress = map(progress, movePhaseEnd, mergePhaseEnd, 0, 1);
      let currentSize = lerp(
        blobSize,
        blobSize * this.balancing_blobMergeFactor,
        phaseProgress
      );
      ellipse(d / 2, 0, currentSize, currentSize);
    } else {
      let phaseProgress = map(progress, mergePhaseEnd, disappearPhaseEnd, 0, 1);
      let currentSize = lerp(
        blobSize * this.balancing_blobMergeFactor,
        0,
        phaseProgress
      );
      let currentAlpha = lerp(255, 0, phaseProgress);
      let tempCol = color(
        red(mainCol),
        green(mainCol),
        blue(mainCol),
        currentAlpha
      );
      fill(tempCol);
      ellipse(d / 2, 0, currentSize, currentSize);
    }

    const getPointAndTangent_Balancing = (t_norm) => {
      return {
        position: createVector(t_norm * d, 0),
        tangent: createVector(1, 0).normalize(),
      };
    };
    this._drawPositivityParticles(
      d,
      getPointAndTangent_Balancing,
      this.balancing_animationSpeed
    );

    pop();
  }

  flow(p1, p2, d, ang) {
    let lineThickness = map(
      this.strength,
      0,
      100,
      this.flow_lineBaseThickness,
      this.flow_lineBaseThickness + this.flow_lineStrengthThickness
    );
    let arrowSize = map(
      this.strength,
      0,
      100,
      this.flow_arrowBaseSize,
      this.flow_arrowBaseSize + this.flow_arrowStrengthSize
    );
    let mainCol = this.relationColor;
    // let arrowCol = this.relationColor; // Already mainCol

    push();
    translate(p1.x, p1.y);
    rotate(ang);

    let curvePoints = [];
    for (let i = 0; i <= this.flow_segments; i++) {
      let t = i / this.flow_segments;
      let x = t * d;
      let waveEffect = sin(
        t * this.flow_waveFrequency * d * 0.01 +
          this.time * this.flow_waveTimeSpeed
      );
      let yOffset =
        waveEffect *
        this.flow_waveAmplitude *
        map(this.strength, 0, 100, 0.5, 1.5);
      curvePoints.push(createVector(x, yOffset));
    }

    // Glow based on positivity removed here

    noFill();
    stroke(mainCol);
    strokeWeight(lineThickness);
    beginShape();
    for (let v of curvePoints) {
      vertex(v.x, v.y);
    }
    endShape();

    let segLengths = [];
    let pathTotalLength = 0;
    for (let i = 0; i < curvePoints.length - 1; i++) {
      let len = p5.Vector.dist(curvePoints[i], curvePoints[i + 1]);
      segLengths.push(len);
      pathTotalLength += len;
    }

    if (pathTotalLength > 0.1) {
      // Condition for arrows and particles
      let overallProgress = (this.time * this.flow_animationSpeed) % 1.0;
      let directionPhase = floor(overallProgress * 2);
      let phaseProgressTime = (overallProgress * 2) % 1.0;

      for (let i = 0; i < this.flow_numArrowPairs; i++) {
        let initialPhaseOffset = i / this.flow_numArrowPairs;
        let progress = (phaseProgressTime + initialPhaseOffset) % 1;
        let distAlongPath;
        let baseAngleOffset = 0;

        if (directionPhase === 0) {
          distAlongPath = progress * pathTotalLength;
        } else {
          distAlongPath = (1 - progress) * pathTotalLength;
          baseAngleOffset = PI;
        }

        let currentDist = 0;
        for (let k = 0; k < segLengths.length; k++) {
          if (currentDist + segLengths[k] >= distAlongPath) {
            let partProgress =
              (distAlongPath - currentDist) /
              (segLengths[k] > 0 ? segLengths[k] : 1);
            partProgress = constrain(partProgress, 0, 1);
            let pA = curvePoints[k];
            let pB = curvePoints[k + 1];
            let finalPos = p5.Vector.lerp(pA, pB, partProgress);
            let dirVec = p5.Vector.sub(pB, pA);
            let finalAngle = dirVec.heading() + baseAngleOffset;
            this.drawArrow(
              finalPos.x,
              finalPos.y,
              finalAngle,
              arrowSize,
              mainCol
            );
            break;
          }
          currentDist += segLengths[k];
        }
      }

      // Add positivity particles for flow
      const getPointAndTangent_Flow = (t_norm) => {
        if (t_norm < 0 || t_norm > 1) t_norm = ((t_norm % 1.0) + 1.0) % 1.0;
        let distTarget = t_norm * pathTotalLength;
        let currentDist = 0;
        for (let k = 0; k < segLengths.length; k++) {
          if (currentDist + segLengths[k] >= distTarget) {
            let partProg =
              (distTarget - currentDist) /
              (segLengths[k] > 0 ? segLengths[k] : 0.001);
            partProg = constrain(partProg, 0, 1);
            let pA = curvePoints[k];
            let pB = curvePoints[k + 1];
            let pos = p5.Vector.lerp(pA, pB, partProg);
            let tangent = p5.Vector.sub(pB, pA);
            if (tangent.magSq() < 0.0001) {
              // Avoid issues with zero-length segments
              if (k > 0)
                tangent = p5.Vector.sub(curvePoints[k], curvePoints[k - 1]);
              else tangent = createVector(1, 0); // Fallback
            }
            return { position: pos, tangent: tangent.normalize() };
          }
          currentDist += segLengths[k];
        }
        // Fallback for t_norm approx 1 or if loop finishes unexpectedly
        let lastTangent = p5.Vector.sub(
          curvePoints[curvePoints.length - 1],
          curvePoints[curvePoints.length - 2]
        );
        if (lastTangent.magSq() < 0.0001) lastTangent = createVector(1, 0);
        return {
          position: curvePoints[curvePoints.length - 1].copy(),
          tangent: lastTangent.normalize(),
        };
      };
      this._drawPositivityParticles(
        pathTotalLength,
        getPointAndTangent_Flow,
        this.flow_animationSpeed
      );
    }
    pop();
  }

  resonance(p1, p2, d, ang) {
    let baseLength = map(
      this.strength,
      0,
      100,
      this.resonance_rectBaseLength,
      this.resonance_rectBaseLength + this.resonance_rectStrengthLength
    );
    let rectWidth = map(
      this.strength,
      0,
      100,
      this.resonance_rectBaseWidth,
      this.resonance_rectBaseWidth + this.resonance_rectStrengthWidth
    );
    let mainCol = this.relationColor;
    let rectLengths = this.resonance_lengthRatios.map(
      (ratio) => baseLength * ratio
    );
    let spacing = rectLengths[0] * this.resonance_spacingFactor;

    let overallProgress = (this.time * this.resonance_animationSpeed) % 1.0;
    let directionPhase = floor(overallProgress * 2);
    let phaseProgress = (overallProgress * 2) % 1.0;

    push();
    translate(p1.x, p1.y);
    rotate(ang);
    rectMode(CENTER);

    let groupFrontToBackSpan = 0;
    if (rectLengths.length > 0) {
      groupFrontToBackSpan =
        (rectLengths.length - 1) * spacing +
        rectLengths[rectLengths.length - 1];
    }
    let effectiveTravelDist = d + groupFrontToBackSpan;
    let groupLeadPos =
      phaseProgress * effectiveTravelDist - groupFrontToBackSpan / 2;

    for (let i = 0; i < rectLengths.length; i++) {
      let currentRectLength = rectLengths[i];
      let x_offset = i * spacing;
      let rectCenterPos;

      if (directionPhase === 0) {
        rectCenterPos = groupLeadPos - x_offset;
      } else {
        rectCenterPos = d - (groupLeadPos - x_offset);
      }

      if (
        rectCenterPos + currentRectLength / 2 > -rectLengths[0] &&
        rectCenterPos - currentRectLength / 2 < d + rectLengths[0]
      ) {
        // Glow based on positivity removed here
        fill(mainCol);
        noStroke();
        rect(rectCenterPos, 0, currentRectLength, rectWidth);
      }
    }

    const getPointAndTangent_Resonance = (t_norm) => {
      return {
        position: createVector(t_norm * d, 0),
        tangent: createVector(1, 0).normalize(),
      };
    };
    this._drawPositivityParticles(
      d,
      getPointAndTangent_Resonance,
      this.resonance_animationSpeed
    );

    pop();
  }

  delaying(p1, p2, d, ang) {
    let lineThickness = map(
      this.strength,
      0,
      100,
      this.delaying_lineBaseThickness,
      this.delaying_lineBaseThickness + this.delaying_lineStrengthThickness
    );
    let arrowSize = map(
      this.strength,
      0,
      100,
      this.delaying_arrowBaseSize,
      this.delaying_arrowBaseSize + this.delaying_arrowStrengthSize
    );
    let mainCol = this.relationColor;

    push();
    translate(p1.x, p1.y);
    rotate(ang);

    let overallCycleProgress = (this.time * this.delaying_animationSpeed) % 1.0;
    let directionPhase = floor(overallCycleProgress * 2);
    let leaderLinearProgress = (overallCycleProgress * 2) % 1.0;

    let startX = 0;
    let endX = d;
    let arrowAngle = 0;

    if (directionPhase === 1) {
      startX = d;
      endX = 0;
      arrowAngle = PI;
    }

    let easedLeaderProgress = this.easeOutDynamic(
      leaderLinearProgress,
      this.delaying_leaderDecelerationFactor
    );
    let posLeaderX = lerp(startX, endX, easedLeaderProgress);

    let followerTargetLinearProgress = 0;
    if (leaderLinearProgress >= this.delaying_leaderStartProgress) {
      let activeTimeForFollower =
        leaderLinearProgress - this.delaying_leaderStartProgress;
      followerTargetLinearProgress =
        activeTimeForFollower * this.delaying_followerRelativeSpeed;
    }
    followerTargetLinearProgress = constrain(
      followerTargetLinearProgress,
      0,
      leaderLinearProgress
    );
    followerTargetLinearProgress = constrain(
      followerTargetLinearProgress,
      0,
      1.0
    );

    let easedFollowerProgress = this.easeOutDynamic(
      followerTargetLinearProgress,
      this.delaying_leaderDecelerationFactor
    );
    let posFollowerX = lerp(startX, endX, easedFollowerProgress);

    let wireDistance = abs(posLeaderX - posFollowerX);

    // Glow based on positivity removed here

    stroke(mainCol);
    strokeWeight(lineThickness);
    line(posFollowerX, 0, posLeaderX, 0);

    this.drawArrow(posLeaderX, 0, arrowAngle, arrowSize, mainCol);
    if (
      followerTargetLinearProgress > 0 ||
      this.delaying_leaderStartProgress === 0
    ) {
      this.drawArrow(posFollowerX, 0, arrowAngle, arrowSize, mainCol);
    }

    if (wireDistance > 0.1) {
      const getPointAndTangent_Delaying = (t_norm) => {
        let xPos = lerp(posFollowerX, posLeaderX, t_norm);
        let tangentVec = createVector(posLeaderX - posFollowerX, 0);
        if (tangentVec.magSq() < 0.0001 && directionPhase === 0)
          tangentVec = createVector(1, 0);
        else if (tangentVec.magSq() < 0.0001 && directionPhase === 1)
          tangentVec = createVector(-1, 0);
        else tangentVec.normalize();
        return {
          position: createVector(xPos, 0),
          tangent: tangentVec,
        };
      };
      this._drawPositivityParticles(
        wireDistance,
        getPointAndTangent_Delaying,
        this.delaying_animationSpeed
      );
    }
    pop();
  }

  amplifying(p1, p2, d, ang) {
    let weight = map(
      this.strength,
      0,
      100,
      this.amplifying_baseStrokeWeight,
      this.amplifying_baseStrokeWeight + this.amplifying_strengthStrokeWeight
    );
    let currentAmplitude = map(
      this.strength,
      0,
      100,
      this.amplifying_baseAmplitude,
      this.amplifying_baseAmplitude + this.amplifying_strengthAmplitude
    );

    push();
    translate(p1.x, p1.y);
    rotate(ang);

    // Call soundLine with d (distance along transformed x-axis)
    this.soundLine(
      d,
      currentAmplitude,
      this.amplifying_lineSegmentsIncrement,
      this.time, // Global time
      weight,
      this.relationColor
    );

    const getPointAndTangent_Amplifying = (t_norm) => {
      // Particles along the central axis of the sound wave
      return {
        position: createVector(t_norm * d, 0),
        tangent: createVector(1, 0).normalize(),
      };
    };
    this._drawPositivityParticles(
      d,
      getPointAndTangent_Amplifying,
      this.amplifying_animationSpeed
    );

    pop();
  }

  soundLine(dist, mainAmplitude, increment, animationTime, weight, strokeCol) {
    let prevX = 0;
    let currentX = 0;
    let prevY = 0;
    let currentY = 0;
    let envelopeAmplifier = 0; // For amplitude shaping/envelope

    strokeWeight(weight);
    stroke(strokeCol);
    noFill();

    for (let i = 0; i <= dist; i += increment) {
      currentX = i; // Use i directly for currentX to avoid accumulation errors and ensure it reaches dist

      let noiseVal = noise(
        i * this.amplifying_noiseScaleSpatial,
        animationTime * this.amplifying_noiseScaleTime
      );

      // Calculate envelope (0 to 1)
      let progress = i / dist;
      if (progress < 1 / 6) {
        envelopeAmplifier = map(progress, 0, 1 / 6, 0, 1);
      } else if (progress < 5 / 6) {
        envelopeAmplifier = 1;
      } else {
        envelopeAmplifier = map(progress, 5 / 6, 1, 1, 0);
      }
      envelopeAmplifier = constrain(envelopeAmplifier, 0, 1);

      // Calculate Y position
      // noise() is 0-1, so (noiseVal-0.5)*2 is -1 to 1.
      currentY = (noiseVal - 0.5) * 2 * mainAmplitude * envelopeAmplifier;

      if (i > 0) {
        // Don't draw line for the very first point
        line(prevX, prevY, currentX, currentY);
      }
      prevX = currentX;
      prevY = currentY;
    }
  }

  easeOutDynamic(t, factor) {
    if (factor <= 1 || factor === undefined) return t;
    return 1 - pow(1 - constrain(t, 0, 1), factor);
  }
}
