///////////
// THIS CODE FILE WAS FOR >90% GENERATED BY GOOGLE AI GEMINI 2.5 PREVIEW 05-06
///////////

// Assuming p5.js environment with global functions like color, random, push, pop, etc.
// Placeholder for getColor if it's not provided externally in your setup
if (typeof getColor === "undefined") {
  function getColor() {
    return [random(100, 220), random(100, 220), random(100, 220)];
  }
}

class Relation {
  constructor(e1, e2, type) {
    this.e1 = e1;
    this.e2 = e2;
    this.type = type;
    this.time = 0; // Time is still used for other animations, just not sign movement
    this.strength = 50;
    this.positivity = 0; // 0-100, 50 is neutral
    this.relationColor = color(getColor());

    // --- Tweakable Parameters ---

    // Undefined (Neutral) Relation
    this.undefined_strokeAlpha = 150;
    this.undefined_baseThicknessMin = 4;
    this.undefined_baseThicknessMax = 12;
    this.undefined_endFactor = 1.5;
    this.undefined_radiusInfluence = 0.05;
    this.undefined_animationSpeed = 0.005; // Used for other animations if any for this type

    // Balancing Relation
    this.balancing_lineBaseThickness = 2;
    this.balancing_lineStrengthThickness = 5;
    this.balancing_blobBaseSize = 15;
    this.balancing_blobStrengthSize = 25;
    this.balancing_blobMergeFactor = 1.6;
    this.balancing_animationSpeed = 0.015;

    // Flow Relation
    this.flow_lineBaseThickness = 1;
    this.flow_lineStrengthThickness = 4;
    this.flow_numArrowPairs = 3;
    this.flow_arrowBaseSize = 16;
    this.flow_arrowStrengthSize = 6;
    this.flow_animationSpeed = 0.002;
    this.flow_waveAmplitude = 7;
    this.flow_waveFrequency = 0.1;
    this.flow_waveTimeSpeed = 0.05;
    this.flow_segments = 15;

    // Resonance Relation
    this.resonance_rectBaseLength = 8;
    this.resonance_rectStrengthLength = 12;
    this.resonance_rectBaseWidth = 3;
    this.resonance_rectStrengthWidth = 100;
    this.resonance_lengthRatios = [1.3, 0.75, 0.2];
    this.resonance_animationSpeed = 0.003;
    this.resonance_spacingFactor = 1.2;

    // Delaying Relation
    this.delaying_lineBaseThickness = 0.5;
    this.delaying_lineStrengthThickness = 3;
    this.delaying_arrowBaseSize = 7;
    this.delaying_arrowStrengthSize = 8;
    this.delaying_animationSpeed = 0.003;
    this.delaying_leaderStartProgress = 0.15;
    this.delaying_followerRelativeSpeed = 1.1;
    this.delaying_leaderDecelerationFactor = 3;

    // Amplifying Relation
    this.amplifying_baseStrokeWeight = 2;
    this.amplifying_strengthStrokeWeight = 2.0;
    this.amplifying_baseAmplitude = 3;
    this.amplifying_strengthAmplitude = 15;
    this.amplifying_noiseScaleSpatial = 0.05;
    this.amplifying_noiseScaleTime = 0.05; // Used for the wave itself
    this.amplifying_lineSegmentsIncrement = 2;
    this.amplifying_animationSpeed = 0.01; // Not used for signs directly

    // Glow Effect (Parameters kept if you want to reuse drawGlow for other purposes)
    this.glow_blurSteps = 8;
    this.glow_maxOpacity = 70;
    this.glow_sizeFactor = 10.0;

    // --- Positivity Signs Parameters ---
    this.positivity_showSigns = false;
    this.positivity_signBaseSize = 9;
    this.positivity_signStrengthSizeFactor = 1.3;
    this.positivity_signBaseCountFactor = 0.05;
    this.positivity_signStrengthCountFactor = 1.1;
    this.positivity_signPositivityCountFactor = 0.1;
    this.positivity_signMinCount = 0;
    this.positivity_signMaxCount = 10; // Max potential static slots
    this.positivity_plusColor = color(0, 180, 0, 220);
    this.positivity_minusColor = color(220, 0, 0, 220);
    this.positivity_signStrokeWeight = 2.2;
    this.positivity_signMaxTiltDeg = 30;
    this.positivity_signDistributionSeed = random(10000);
    this.positivity_signJitterMax = 30; // Increased for better visibility

    // --- Label Configuration ---
    this.label_show = true;
    this.label_textColor = color("#282828");
    this.label_textSize = 11;
    this.label_textOffsetY = -15;
    this.label_showBackground = true;
    this.label_backgroundColor = color(255, 255, 255, 170);
    this.label_backgroundPadding = 4;
    this.label_backgroundCornerRadius = 3;
    this.label_maxAngleDeg = 45;

    // Pre-calculate static positions for signs (t-values along the path)
    this._staticSignTValues = [];
    this._staticSignTilts = [];
    this._staticSignJitterFactors = []; // Store jitter factors (x, y multipliers)

    this._staticSignData = []; // Array of objects {t, tilt, jitterFactor}

    let tempRandomSeed = this.positivity_signDistributionSeed;

    for (let i = 0; i < this.positivity_signMaxCount; i++) {
      let tValueNoise = noise(tempRandomSeed + i * 0.1);
      let tiltNoise = noise(tempRandomSeed + i * 0.1 + 1000);
      let jitterNoise = noise(tempRandomSeed + i * 0.1 + 2000);

      let baseT = (i + 0.5) / this.positivity_signMaxCount;
      let noisyT = baseT * 0.7 + tValueNoise * 0.3;

      this._staticSignData.push({
        t: constrain(noisyT, 0.05, 0.95),
        tilt: radians(
          map(
            tiltNoise,
            0,
            1,
            -this.positivity_signMaxTiltDeg,
            this.positivity_signMaxTiltDeg
          )
        ),
        jitterFactor: map(jitterNoise, 0, 1, -1, 1),
      });
    }

    // Sort the static sign data by their t-value (position along the path)
    // This ensures that when we pick a "centered" subset, it's truly centered spatially.
    this._staticSignData.sort((a, b) => a.t - b.t);
  }

  _getDefaultLabelOptions() {
    return {
      textColor: this.label_textColor,
      textSize: this.label_textSize,
      textOffsetY: this.label_textOffsetY,
      showBackground: this.label_showBackground,
      backgroundColor: this.label_backgroundColor,
      backgroundPadding: this.label_backgroundPadding,
      backgroundCornerRadius: this.label_backgroundCornerRadius,
      maxAngleDeg: this.label_maxAngleDeg,
    };
  }

  displayLabel(overrideOptions = {}) {
    const config = { ...this._getDefaultLabelOptions(), ...overrideOptions };
    const e1Pos = createVector(this.e1.x, this.e1.y);
    const e2Pos = createVector(this.e2.x, this.e2.y);

    if (p5.Vector.dist(e1Pos, e2Pos) < config.textSize * 2) return;

    const midX = (e1Pos.x + e2Pos.x) / 2;
    const midY = (e1Pos.y + e2Pos.y) / 2;
    const delta = p5.Vector.sub(e2Pos, e1Pos);
    let lineAngle = delta.heading();
    let textAngle = lineAngle;
    const maxAngleRad = radians(config.maxAngleDeg);

    if (textAngle > HALF_PI || textAngle < -HALF_PI) textAngle += PI;
    if (abs(textAngle) > maxAngleRad) textAngle = 0;

    push();
    translate(midX, midY);
    rotate(textAngle);

    let labelText = this.type || "Unknown Type";
    if (labelText === "null") labelText = "";
    if (labelText === "amplifying") labelText = "Reinforcing";

    fill(config.textColor);
    textSize(config.textSize);
    textAlign(CENTER, CENTER);

    if (config.showBackground && labelText !== "") {
      const tw = textWidth(labelText);
      const th = config.textSize;
      push();
      rectMode(CENTER);
      fill(config.backgroundColor);
      noStroke();
      rect(
        0,
        config.textOffsetY,
        tw + config.backgroundPadding * 2,
        th + config.backgroundPadding * 2,
        config.backgroundCornerRadius
      );
      pop();
    }
    text(labelText, 0, config.textOffsetY);
    pop();
  }

  _drawPositivitySigns(pathLength, getPointAndTangentAt) {
    if (
      !this.positivity_showSigns ||
      this.positivity === 50 ||
      pathLength < this.positivity_signBaseSize * 1.5
    )
      return;

    const isPositive = this.positivity > 50;
    const signColor = isPositive
      ? this.positivity_plusColor
      : this.positivity_minusColor;
    const deviation = abs(this.positivity - 50);

    let numSignsToShow = pathLength * this.positivity_signBaseCountFactor;
    numSignsToShow *= map(
      this.strength,
      0,
      100,
      0.7,
      this.positivity_signStrengthCountFactor
    );
    numSignsToShow *= map(
      deviation,
      0,
      50,
      0.05,
      this.positivity_signPositivityCountFactor * 2
    );
    numSignsToShow = constrain(
      floor(numSignsToShow),
      this.positivity_signMinCount,
      this.positivity_signMaxCount
    );

    if (numSignsToShow === 0) return;

    const signSize =
      this.positivity_signBaseSize *
      map(this.strength, 0, 100, 0.8, this.positivity_signStrengthSizeFactor);

    stroke(signColor);
    strokeWeight(this.positivity_signStrokeWeight);
    noFill();

    // Determine the slice of staticSignData to use for center-out spawning
    let startIndex = 0;
    let endIndex = numSignsToShow; // By default, take the first N if not doing center-out

    if (
      this.positivity_signMaxCount > 0 &&
      numSignsToShow < this.positivity_signMaxCount
    ) {
      const middleIndexOfMax = floor(this.positivity_signMaxCount / 2);
      let numToTakeEachSide = floor(numSignsToShow / 2);

      startIndex = middleIndexOfMax - numToTakeEachSide;
      endIndex = middleIndexOfMax + ceil(numSignsToShow / 2); // Use ceil for odd numSignsToShow

      // Ensure indices are within bounds of _staticSignData (which has length positivity_signMaxCount)
      startIndex = constrain(
        startIndex,
        0,
        this.positivity_signMaxCount - numSignsToShow
      );
      endIndex = startIndex + numSignsToShow;
      endIndex = constrain(
        endIndex,
        numSignsToShow,
        this.positivity_signMaxCount
      );
      // Recalculate startIndex if endIndex was constrained and numSignsToShow is small
      if (endIndex - startIndex < numSignsToShow && startIndex > 0) {
        startIndex = endIndex - numSignsToShow;
        startIndex = max(0, startIndex);
      }
    } else {
      // Show all available slots or if numSignsToShow >= max
      startIndex = 0;
      endIndex = min(numSignsToShow, this._staticSignData.length);
    }

    for (let i = startIndex; i < endIndex; i++) {
      // Ensure we don't go out of bounds if logic above has an issue
      if (i >= this._staticSignData.length) break;

      const signData = this._staticSignData[i];
      let currentPathT = signData.t;
      let staticTilt = signData.tilt;
      let jitterFactor = signData.jitterFactor;

      let pointData = getPointAndTangentAt(currentPathT);
      if (!pointData || !pointData.position || !pointData.tangent) continue;

      let { position, tangent } = pointData;
      if (tangent.magSq() < 0.0001) tangent = createVector(1, 0);

      let perpendicular = createVector(-tangent.y, tangent.x).normalize();
      let jitterOffsetAmount = jitterFactor * this.positivity_signJitterMax;
      let jitteredPosition = p5.Vector.add(
        position,
        perpendicular.mult(jitterOffsetAmount)
      );

      let signOrientationAngle = tangent.heading() + staticTilt;

      push();
      translate(jitteredPosition.x, jitteredPosition.y);
      rotate(signOrientationAngle);

      if (isPositive) {
        line(-signSize / 2, 0, signSize / 2, 0);
        line(0, -signSize / 2, 0, signSize / 2);
      } else {
        line(-signSize / 2, 0, signSize / 2, 0);
      }
      pop();
    }
  }

  display() {
    push();
    let e1Pos = createVector(this.e1.x, this.e1.y);
    let e2Pos = createVector(this.e2.x, this.e2.y);
    let delta = p5.Vector.sub(e2Pos, e1Pos);
    let angle = delta.heading();
    let d = delta.mag();

    if (d < 1) {
      if (this.label_show && this.e1 && typeof this.e1.r !== "undefined") {
        this.displayLabel({ textOffsetY: -this.e1.r - this.label_textSize });
      }
      pop();
      this.time += 1; // Still increment time for other animations
      return;
    }

    if (this.type === "undefined")
      this.undefinedRelation(e1Pos, e2Pos, d, angle);
    else if (this.type === "amplifying")
      this.amplifying(e1Pos, e2Pos, d, angle);
    else if (this.type === "balancing") this.balancing(e1Pos, e2Pos, d, angle);
    else if (this.type === "flow") this.flow(e1Pos, e2Pos, d, angle);
    else if (this.type === "resonance") this.resonance(e1Pos, e2Pos, d, angle);
    else if (this.type === "delaying") this.delaying(e1Pos, e2Pos, d, angle);
    this.drawPositivityLine();

    pop();

    if (this.label_show) this.displayLabel();
    this.time += 1; // Increment time for other animations
  }

  drawArrow(x, y, rot, size, col) {
    push();
    translate(x, y);
    rotate(rot);
    fill(col);
    noStroke();
    triangle(0, 0, -size, -size / 2, -size, size / 2);
    pop();
  }

  // --- Relation Specific Drawing Methods ---
  // They now call _drawPositivitySigns without the animationSpeedParam

  undefinedRelation(p1, p2, d, ang) {
    push();
    translate(p1.x, p1.y);
    rotate(ang);
    let midThick = map(
      this.strength,
      0,
      100,
      this.undefined_baseThicknessMin,
      this.undefined_baseThicknessMax
    );
    let end1Inf =
      this.e1.r * this.undefined_radiusInfluence * (this.strength / 100);
    let end2Inf =
      this.e2.r * this.undefined_radiusInfluence * (this.strength / 100);
    let end1Thick = midThick * this.undefined_endFactor + end1Inf;
    let end2Thick = midThick * this.undefined_endFactor + end2Inf;
    fill(
      red(this.relationColor),
      green(this.relationColor),
      blue(this.relationColor),
      this.undefined_strokeAlpha
    );
    noStroke();
    beginShape();
    vertex(0, -end1Thick / 2);
    quadraticVertex(
      d * 0.25,
      -lerp(end1Thick, midThick, 0.5) / 2,
      d * 0.5,
      -midThick / 2
    );
    quadraticVertex(
      d * 0.75,
      -lerp(midThick, end2Thick, 0.5) / 2,
      d,
      -end2Thick / 2
    );
    vertex(d, end2Thick / 2);
    quadraticVertex(
      d * 0.75,
      lerp(midThick, end2Thick, 0.5) / 2,
      d * 0.5,
      midThick / 2
    );
    quadraticVertex(
      d * 0.25,
      lerp(end1Thick, midThick, 0.5) / 2,
      0,
      end1Thick / 2
    );
    endShape(CLOSE);
    const getPointAndTangent_Undefined = (t_norm) => ({
      position: createVector(t_norm * d, 0),
      tangent: createVector(1, 0).normalize(),
    });
    this._drawPositivitySigns(d, getPointAndTangent_Undefined);
    pop();
  }

  balancing(p1, p2, d, ang) {
    push();
    translate(p1.x, p1.y);
    rotate(ang);
    let lineThick = map(
      this.strength,
      0,
      100,
      this.balancing_lineBaseThickness,
      this.balancing_lineBaseThickness + this.balancing_lineStrengthThickness
    );
    let blobS = map(
      this.strength,
      0,
      100,
      this.balancing_blobBaseSize,
      this.balancing_blobBaseSize + this.balancing_blobStrengthSize
    );
    let prog = (this.time * this.balancing_animationSpeed) % 1; // time still used for balancing animation
    let mainC = this.relationColor;
    stroke(mainC);
    strokeWeight(lineThick);
    line(0, 0, d, 0);
    fill(mainC);
    noStroke();
    let mE = 0.4,
      mgE = 0.6,
      dE = 1.0;
    if (prog < mE) {
      let pP = map(prog, 0, mE, 0, 1);
      ellipse(lerp(0, d / 2 - blobS * 0.6, pP), 0, blobS, blobS);
      ellipse(lerp(d, d / 2 + blobS * 0.6, pP), 0, blobS, blobS);
    } else if (prog < mgE) {
      let cS = lerp(
        blobS,
        blobS * this.balancing_blobMergeFactor,
        map(prog, mE, mgE, 0, 1)
      );
      ellipse(d / 2, 0, cS, cS);
    } else {
      let pP = map(prog, mgE, dE, 0, 1);
      let cS = lerp(blobS * this.balancing_blobMergeFactor, 0, pP);
      let cA = lerp(255, 0, pP);
      fill(red(mainC), green(mainC), blue(mainC), cA);
      ellipse(d / 2, 0, cS, cS);
    }
    const getPointAndTangent_Balancing = (t_norm) => ({
      position: createVector(t_norm * d, 0),
      tangent: createVector(1, 0).normalize(),
    });
    this._drawPositivitySigns(d, getPointAndTangent_Balancing);
    pop();
  }

  flow(p1, p2, d, ang) {
    push();
    translate(p1.x, p1.y);
    rotate(ang);
    let lineThick = map(
      this.strength,
      0,
      100,
      this.flow_lineBaseThickness,
      this.flow_lineBaseThickness + this.flow_lineStrengthThickness
    );
    let arrS = map(
      this.strength,
      0,
      100,
      this.flow_arrowBaseSize,
      this.flow_arrowBaseSize + this.flow_arrowStrengthSize
    );
    let mainC = this.relationColor;
    let cPts = [];
    for (let i = 0; i <= this.flow_segments; i++) {
      let t = i / this.flow_segments;
      let x = t * d;
      let wE = sin(
        t * this.flow_waveFrequency * d * 0.01 +
          this.time * this.flow_waveTimeSpeed
      );
      let yOff =
        wE * this.flow_waveAmplitude * map(this.strength, 0, 100, 0.5, 1.5);
      cPts.push(createVector(x, yOff));
    } // time used for wave
    noFill();
    stroke(mainC);
    strokeWeight(lineThick);
    beginShape();
    for (let v of cPts) vertex(v.x, v.y);
    endShape();
    let sLens = [],
      pTL = 0;
    for (let i = 0; i < cPts.length - 1; i++) {
      let len = p5.Vector.dist(cPts[i], cPts[i + 1]);
      sLens.push(len);
      pTL += len;
    }
    if (pTL > 0.1) {
      let oP = (this.time * this.flow_animationSpeed) % 1.0;
      let dP = floor(oP * 2);
      let pPT = (oP * 2) % 1.0; // time used for arrows
      for (let i = 0; i < this.flow_numArrowPairs; i++) {
        let prg = (pPT + i / this.flow_numArrowPairs) % 1;
        let dAP = dP === 0 ? prg * pTL : (1 - prg) * pTL;
        let bAO = dP === 0 ? 0 : PI;
        let cD = 0;
        for (let k = 0; k < sLens.length; k++) {
          if (cD + sLens[k] >= dAP) {
            let ptP = constrain(
              (dAP - cD) / (sLens[k] > 0 ? sLens[k] : 1),
              0,
              1
            );
            let pa = cPts[k],
              pb = cPts[k + 1];
            let fPos = p5.Vector.lerp(pa, pb, ptP);
            let fAng = p5.Vector.sub(pb, pa).heading() + bAO;
            this.drawArrow(fPos.x, fPos.y, fAng, arrS, mainC);
            break;
          }
          cD += sLens[k];
        }
      }
      const getPointAndTangent_Flow = (t_norm) => {
        t_norm = ((t_norm % 1.0) + 1.0) % 1.0;
        let dT = t_norm * pTL;
        let cD = 0;
        for (let k = 0; k < sLens.length; k++) {
          if (cD + sLens[k] >= dT) {
            let pP = constrain(
              (dT - cD) / (sLens[k] > 0 ? sLens[k] : 0.001),
              0,
              1
            );
            let pA = cPts[k],
              pB = cPts[k + 1];
            let pos = p5.Vector.lerp(pA, pB, pP);
            let tan = p5.Vector.sub(pB, pA);
            if (tan.magSq() < 0.0001) {
              if (k > 0 && k < cPts.length - 1)
                tan = p5.Vector.sub(cPts[k + 1], cPts[k - 1]);
              else if (k > 0) tan = p5.Vector.sub(cPts[k], cPts[k - 1]);
              else if (cPts.length > 1) tan = p5.Vector.sub(cPts[1], cPts[0]);
              else tan = createVector(1, 0);
            }
            return { position: pos, tangent: tan.normalize() };
          }
          cD += sLens[k];
        }
        let lP = cPts[cPts.length - 1];
        let sLP =
          cPts.length > 1
            ? cPts[cPts.length - 2]
            : createVector(lP.x - 1, lP.y);
        let lT = p5.Vector.sub(lP, sLP);
        if (lT.magSq() < 0.0001) lT = createVector(1, 0);
        return { position: lP.copy(), tangent: lT.normalize() };
      };
      this._drawPositivitySigns(pTL, getPointAndTangent_Flow);
    }
    pop();
  }

  resonance(p1, p2, d, ang) {
    push();
    translate(p1.x, p1.y);
    rotate(ang);
    rectMode(CENTER);
    let bL = map(
      this.strength,
      0,
      100,
      this.resonance_rectBaseLength,
      this.resonance_rectBaseLength + this.resonance_rectStrengthLength
    );
    let rW = map(
      this.strength,
      0,
      100,
      this.resonance_rectBaseWidth,
      this.resonance_rectBaseWidth + this.resonance_rectStrengthWidth
    );
    let mC = this.relationColor;
    let rLs = this.resonance_lengthRatios.map((r) => bL * r);
    let sp = rLs[0] * this.resonance_spacingFactor;
    let oP = (this.time * this.resonance_animationSpeed) % 1.0;
    let dP = floor(oP * 2);
    let pP = (oP * 2) % 1.0; // time used for rects
    let gFTS = rLs.length > 0 ? (rLs.length - 1) * sp + rLs[rLs.length - 1] : 0;
    let eTD = d + gFTS;
    let gLP = pP * eTD - gFTS / 2;
    fill(mC);
    noStroke();
    for (let i = 0; i < rLs.length; i++) {
      let cRL = rLs[i];
      let xO = i * sp;
      let rCP = dP === 0 ? gLP - xO : d - (gLP - xO);
      if (rCP + cRL / 2 > -rLs[0] && rCP - cRL / 2 < d + rLs[0]) {
        rect(rCP, 0, cRL, rW);
      }
    }
    const getPointAndTangent_Resonance = (t_norm) => ({
      position: createVector(t_norm * d, 0),
      tangent: createVector(1, 0).normalize(),
    });
    this._drawPositivitySigns(d, getPointAndTangent_Resonance);
    pop();
  }

  delaying(p1, p2, d, ang) {
    push();
    translate(p1.x, p1.y);
    rotate(ang);
    let lT = map(
      this.strength,
      0,
      100,
      this.delaying_lineBaseThickness,
      this.delaying_lineBaseThickness + this.delaying_lineStrengthThickness
    );
    let aS = map(
      this.strength,
      0,
      100,
      this.delaying_arrowBaseSize,
      this.delaying_arrowBaseSize + this.delaying_arrowStrengthSize
    );
    let mC = this.relationColor;
    let oCP = (this.time * this.delaying_animationSpeed) % 1.0;
    let dP = floor(oCP * 2);
    let lLP = (oCP * 2) % 1.0; // time used for arrows
    let sX = dP === 0 ? 0 : d;
    let eX = dP === 0 ? d : 0;
    let aA = dP === 0 ? 0 : PI;
    let eLP = this.easeOutDynamic(lLP, this.delaying_leaderDecelerationFactor);
    let pLX = lerp(sX, eX, eLP);
    let fTLP = 0;
    if (lLP >= this.delaying_leaderStartProgress) {
      fTLP =
        (lLP - this.delaying_leaderStartProgress) *
        this.delaying_followerRelativeSpeed;
    }
    fTLP = constrain(fTLP, 0, lLP);
    fTLP = constrain(fTLP, 0, 1.0);
    let eFP = this.easeOutDynamic(fTLP, this.delaying_leaderDecelerationFactor);
    let pFX = lerp(sX, eX, eFP);
    stroke(mC);
    strokeWeight(lT);
    line(pFX, 0, pLX, 0);
    this.drawArrow(pLX, 0, aA, aS, mC);
    if (fTLP > 0 || this.delaying_leaderStartProgress === 0) {
      this.drawArrow(pFX, 0, aA, aS, mC);
    }
    let wD = abs(pLX - pFX);
    if (wD > 0.1) {
      const getPointAndTangent_Delaying = (t_norm) => {
        let xP = lerp(pFX, pLX, t_norm);
        let tV = createVector(pLX - pFX, 0);
        if (tV.magSq() < 0.0001)
          tV = dP === 0 ? createVector(1, 0) : createVector(-1, 0);
        return { position: createVector(xP, 0), tangent: tV.normalize() };
      };
      this._drawPositivitySigns(wD, getPointAndTangent_Delaying);
    }
    pop();
  }

  amplifying(p1, p2, d, ang) {
    push();
    translate(p1.x, p1.y);
    rotate(ang);
    let w = map(
      this.strength,
      0,
      100,
      this.amplifying_baseStrokeWeight,
      this.amplifying_baseStrokeWeight + this.amplifying_strengthStrokeWeight
    );
    let cA = map(
      this.strength,
      0,
      100,
      this.amplifying_baseAmplitude,
      this.amplifying_baseAmplitude + this.amplifying_strengthAmplitude
    );
    this.soundLine(
      d,
      cA,
      this.amplifying_lineSegmentsIncrement,
      this.time,
      w,
      this.relationColor
    ); // time used for sound wave
    const getPointAndTangent_Amplifying = (t_norm) => ({
      position: createVector(t_norm * d, 0),
      tangent: createVector(1, 0).normalize(),
    });
    this._drawPositivitySigns(d, getPointAndTangent_Amplifying);
    pop();
  }

  soundLine(dist, mainAmplitude, increment, animationTime, weight, strokeCol) {
    let pX = 0,
      cX = 0,
      pY = 0,
      cY = 0,
      eA = 0;
    strokeWeight(weight);
    stroke(strokeCol);
    noFill();
    for (let i = 0; i <= dist; i += increment) {
      cX = i;
      let nV = noise(
        i * this.amplifying_noiseScaleSpatial,
        animationTime * this.amplifying_noiseScaleTime
      );
      let prg = i / dist;
      if (prg < 1 / 6) eA = map(prg, 0, 1 / 6, 0, 1);
      else if (prg < 5 / 6) eA = 1;
      else eA = map(prg, 5 / 6, 1, 1, 0);
      cY = (nV - 0.5) * 2 * mainAmplitude * constrain(eA, 0, 1);
      if (i > 0) line(pX, pY, cX, cY);
      pX = cX;
      pY = cY;
    }
  }

  easeOutDynamic(t, factor) {
    if (factor <= 1 || factor === undefined) return t;
    return 1 - pow(1 - constrain(t, 0, 1), factor);
  }

  drawPositivityLine() {
    if (this.positivity > 10 || this.positivity < -10) {
      let start = createVector(this.e1.x, this.e1.y);
      let end = createVector(this.e2.x, this.e2.y);
      let dir = p5.Vector.sub(end, start);
      let len = dir.mag();

      let magnitude = abs(this.positivity) - 10;
      let count = constrain(magnitude, 1, 40);

      dir.normalize();
      let perp = createVector(-dir.y, dir.x);

      // Generate consistent offsets if not present or count changed
      if (!this.positivityOffsets || this.positivityOffsets.length !== count) {
        this.positivityOffsets = [];
        for (let i = 0; i < count; i++) {
          // Reduced jitter range to max ±15px
          this.positivityOffsets.push(random(-15, 15));
        }
      }

      for (let i = 0; i < count; i++) {
        let t = count === 1 ? 0.5 : i / (count - 1); // Avoid division by 0
        let base = p5.Vector.lerp(start, end, t);
        let offset = this.positivityOffsets[i];
        let distorted = p5.Vector.add(base, p5.Vector.mult(perp, offset));

        push();
        textAlign(CENTER, CENTER);
        textSize(25);
        noStroke();
        if (this.positivity > 10) {
          fill("#00fa04");
          text("+", distorted.x, distorted.y);
        } else {
          fill("#FF0000");
          text("-", distorted.x, distorted.y);
        }
        pop();
      }
    }
  }
}
